pragma solidity ^0.5.4;

contract Ownable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor () internal {
        _owner = tx.origin;
        emit OwnershipTransferred(address(0), _owner);
    }

    function owner() public view returns (address) {
        return _owner;
    }

    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    function isOwner() public view returns (bool) {
        return tx.origin == _owner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}

contract Ballot is Ownable {
    
    mapping(uint256 => string)  password;
    mapping(uint256 => string) otp;
    mapping(uint256 => string) plusmark;
    mapping(uint256 => bool) isVoted;
    mapping(uint256 => uint256) voteCount;
    mapping(uint256 => string) feedback;
    mapping(uint256 => bool) myStudent;
    mapping(uint256 => uint256[]) votedTo;
    mapping(uint256 => uint256) group;
    bool isLocked;
    
    modifier isValidOTP(uint256 _mssv, string memory _otp) {
        require(keccak256(abi.encodePacked((otp[_mssv]))) == keccak256(abi.encodePacked((_otp))));
        _;
    }
    
    modifier unLocked() {
        require(isLocked != true);
        _;
    }
    
    modifier isMyStudent(uint256 _mssv) {
        require(myStudent[_mssv] == true);
        _;
    }
    
    modifier isValidPassword(uint256 _mssv, string memory _password) {
        require(keccak256(abi.encodePacked((password[_mssv]))) == keccak256(abi.encodePacked((_password))));
        _;
    }
    
     modifier hasPassword(uint256 _mssv) {
        bytes memory tempEmptyString = bytes(password[_mssv]); 
        require(tempEmptyString.length > 0);
        _;
    }
    
    function _votedToFriend(uint256 _mssv, uint256 _friend) private returns (uint256) {
        for (uint index=0; index < votedTo[_mssv].length; index++) {
            if (votedTo[_mssv][index] == _friend) {return index;}
        }
        return 10;
    }
    
    function initial(uint256 _mssv, string memory _otp, uint256 _groupNum) public onlyOwner {
        otp[_mssv] = _otp;
        myStudent[_mssv] = true;
        group[_mssv] = _groupNum;
    }
    
    function setPlusMark(uint256 _mssv, string memory _plusmark) public onlyOwner {
        plusmark[_mssv] = _plusmark;
    }
    
    function changLock(bool _value) public onlyOwner {
        isLocked = _value;
    }
    
    function getPlusMark(uint256 _mssv) public view returns (string memory) {
        return plusmark[_mssv];
    }
    
    function getOTP(uint256 _mssv) public onlyOwner  view returns (string memory) {
        return otp[_mssv];
    }
    
    function isValidStudent(uint256 _mssv) public view returns (bool) {
        return myStudent[_mssv];
    }
    
    function setPassword(uint256 _mssv, string memory _otp, string memory _password) 
    public 
    isMyStudent(_mssv)
    unLocked
    isValidOTP(_mssv, _otp) 
    {
        password[_mssv] = _password;
    } 
    
    function vote(uint256 _mssv, uint256[] memory _friends, string memory _password) 
    public 
    isMyStudent(_mssv)
    unLocked
    hasPassword(_mssv)
    isValidPassword(_mssv, _password)
    {
        for (uint index=0; index < _friends.length; index++) {
            require(_mssv != _friends[index]);
            require(_votedToFriend(_mssv, _friends[index]) == 10);
            require(group[_mssv] == group[_friends[index]]);
            votedTo[_mssv].push(_friends[index]);
            uint256 count = voteCount[_friends[index]];
            voteCount[_friends[index]] = count+1;
        }
    }
    
    function sendFeedback(uint256 _mssv, string memory _feedback, string memory _password) 
    public 
    isMyStudent(_mssv)
    unLocked
    hasPassword(_mssv)
    isValidPassword(_mssv, _password)
    {
        /* Feedback sử dụng Điểm cộng: Lựa chọn một trong các Options sau
           "1" - Ưu tiên cộng vào Bài tập lớn
           "2" - Ưu tiên cộng vào Bài Lab
           "3" - Ưu tiên cộng cho Crush: MSSV_Crush
           "4" - Đóng góp vào quỹ chung, để TA tặng cho bạn nào cần
           Ý kiến khác */
        feedback[_mssv] = _feedback;
    }
    
    function getVoteCount(uint256 _mssv, string memory _password) public hasPassword(_mssv) isValidPassword(_mssv, _password) view returns (uint256) {
        return voteCount[_mssv];
    }
    
    function getVoteCountOfMySudent(uint256 _mssv) public onlyOwner view returns (uint256) {
        return voteCount[_mssv];
    }
    
    function getGroup(uint256 _mssv) public view returns (uint256) {
        return group[_mssv];
    }
    
}